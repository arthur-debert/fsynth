FSYNTH: SYNTHETIC FILESYSTEM FOR ISOLATED OPERATIONS
===================================================

1. Purpose and Rationale
-------------------------

Fsynth provides a synthetic filesystem abstraction to isolate and queue 
filesystem operations for batch execution. The primary goal is to separate 
planning from execution, allowing most of the codebase to remain functional 
and side-effect free. This approach:

- Makes code easier to test by isolating side effects
- Enables dry-run capabilities without code duplication
- Improves reliability by enabling pre-execution validation
- Allows for proper error handling and optional partial rollback

Fsynth isn't intended for data-critical or concurrent environments. It's 
designed for simple, reliable file operation batching with appropriate 
safeguards.


2. Core Design Principles
--------------------------

a. PURE PLANNING, ISOLATED EXECUTION
   Build an operation queue without making any actual filesystem changes,
   then execute the queue in a controlled, isolated part of the codebase.
b. CONTENT VERIFICATION
   Each file operation should checksum source and target files where
   appropriate. This enables:
   - Verification that the source file hasn't changed since planning
   - Detection of target file changes before overwriting
   - Optional backing down if content has changed

c. SAFE DIRECTORY HANDLING
   When processing directories:
   - Use an accumulator to track processed items
   - Implement a configurable maximum to prevent processing huge directories
   - Provide a clear mechanism to skip/include dotfiles

d. ROLLBACK CAPABILITY
   While not promising full transaction semantics, fsynth should attempt
   reasonable rollback of failed operation batches.

e. IMMUTABILITY AND FUNCTIONAL APPROACH
   Once an operation is created, its parameters should be immutable.
   This helps with debugging and ensures operations don't unexpectedly
   change behavior between creation and execution.


3. API Design
-------------

The API follows the Command pattern with a queue-based approach.

a. OPERATION INTERFACE [1]
   Each operation encapsulates a specific filesystem action with a standard
   interface including:
   - execute(): performs the operation
   - validate(): pre-checks operation validity
   - checksum(): generates or verifies checksums
   - undo(): reverses the operation (when possible)

b. QUEUE MANAGEMENT [2]
   The system uses an efficient queue implementation with O(1) enqueue/dequeue
   operations.

c. BASIC OPERATIONS
   Core operations include:
   - CopyFile: Copy a file with checksum verification
   - SymlinkFile: Create a symlink
   - CreateDirectory: Create a directory (and parent dirs if needed)
   - DeleteFile: Remove a file with optional backup
   - DeleteDirectory: Remove a directory with safety limits
   - MoveFile: Move a file with checksum verification
   - ChmodFile: Change file permissions

d. PROCESSOR INTERFACE [3]
   The processor executes the operation queue with proper error handling
   and optional rollback.



4. Implementation Details
--------------------

a. OPERATION REPRESENTATION
   Each operation is a Lua table with methods (using metatables) that include:
   - Common fields: source, target, options, checksum_data
   - Operation-specific fields as needed
   - Standard methods matching the operation interface

b. CHECKSUMMING
   - Use SHA-256 for robust checksumming
   - Store checksums for both source and target files
   - Options to compare checksums before operations
   - Options to bail out if checksums don't match expectations

c. DIRECTORY HANDLING
   - Implement iteration with item counting
   - Configurable max_items parameter (default reasonably low, ~1000)
   - Store current count in an accumulator object
   - Clear warning/error when limit is reached

d. ERROR HANDLING
   |    - Detailed error messages with context
   |    - Error classification (fatal vs. non-fatal)
   |    - Option to continue on non-fatal errors
   |    - Logging of all operations and errors
   |
   | 5. LOGGING
   |    - Uses the `log` library for all logging operations
   |    - Log file is automatically truncated at startup
   |    - Default log level is "info" for console output
   |    - All levels (trace through fatal) are logged to file
   |    - Log file is stored at "/var/tmp/lua-fsynth.log"
   |    - Log entries include timestamp, source file, and line number
   |    - Always use the log module instead of print statements
   |
   | 6. EXECUTION MODELS
   - Standard: Execute operations in order, stopping on first error
   - Validate-first: Validate all operations before executing any
   - Best-effort: Try all operations, collecting errors
   - Transactional: Attempt rollback of completed operations on failure



5. Integration with Existing Systems
-------------------------------

Fsynth is designed to work with Penlight for path handling and filesystem
operations. Key integration points:

a. Leveraging Penlight's path functions for normalization, joining, etc.
b. Using pl.dir for directory operations when appropriate
c. Wrapping pl.file functions for file operations
d. Using Penlight's utility functions where helpful

The library will be tested with Busted, using mocks to isolate filesystem
operations for unit testing.



6. Testing 
----------

a. UNIT TESTING
   - Test each operation type in isolation
   - Test validation, execution, and rollback separately
   - Test queue management independently

b. INTEGRATION TESTING
   - Test full execution flows with controlled test directories
   - Verify proper handling of edge cases (permissions, etc.)
   - Test with various execution models

c. Testing Commands

    luarocks test 
    busted 


7. Dependencies and LuaRocks
-----------------------------

Fsynth uses LuaRocks for dependency management with project-isolated dependencies stored in a .luarocks directory tree. This approach keeps the project's dependencies separate from system-wide installations, preventing version conflicts and ensuring reproducible builds.

a. REQUIRED DEPENDENCIES
   - lua >= 5.1
   - penlight >= 1.5.0 -> all base file ops
   - log.lua >= 0.1.0 -> no print statements, always use
   - string-format-all >= 0.2.0 -> all string formatting should use

b. TEST DEPENDENCIES
   - busted >= 2.0.0

c. ENVIRONMENT SETUP SCRIPTS

   # Setup Lua environment (adds paths to dependencies)
   source ./bin/luapath.sh

   # Run tests with the correct environment
   ./bin/run-tests

d. COMMON LUAROCKS COMMANDS

   # Installing all dependencies from the rockspec file
   luarocks --tree ./.luarocks install --only-deps

   # Installing the package in development mode
   luarocks --tree ./.luarocks make

   # Adding a new dependency
   luarocks --tree ./.luarocks install new_package
   # Then update the rockspec file to include the dependency:
   #   dependencies = {
   #      "lua >= 5.1",
   #      ...
   #      "new_package >= 1.0.0"
   #   }

   # Listing installed packages in the local tree
   luarocks --tree ./.luarocks list

   # Installing a specific version of a package
   luarocks --tree ./.luarocks install log.lua 0.1.0-1

   # Removing a package from the local tree
   luarocks --tree ./.luarocks remove package_name
   luarocks remove log.lua

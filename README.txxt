Fsynth: Synthetic Filesystem for Isolated Operations
===================================================

1. Purpose and Rationale

   Fsynth provides a synthetic filesystem abstraction that isolates and queues
   filesystem operations for batch execution. The system separates planning from 
   execution, allowing most of the codebase to remain functional and side-effect free.

   For example, scripts that perform a series of simple filesystem operations (creating 
   directories, adding files, creating links) can generate the filesystem operations in 
   a queue for later execution. This approach:

      - Makes code easier to test by isolating side effects
      - Enables dry-run capabilities without code duplication
      - Improves reliability through pre-execution validation
      - Allows for proper error handling and optional partial rollback

   Fsynth is not intended for data-critical or concurrent environments. It is
   designed for simple, reliable file operation batching with appropriate
   safeguards. Note that using it in high concurrency environments will result in data loss.


2. Core Design Principles

a. Pure Planning, Isolated Execution
   
   Fsynth builds an operation queue without making any actual filesystem changes,
   then executes the queue in a controlled, isolated part of the codebase.

b. Content Verification

   Each file operation checksums source and target files where
   appropriate. This enables:
      
      - Verification that the source file hasn't changed since planning
      - Detection of target file changes before overwriting
      - Optional backing down if content has changed

c. Safe Directory Handling

   When processing directories, Fsynth:
      - Uses an accumulator to track processed items
      - Implements a configurable maximum to prevent processing huge directories
      - Provides a clear mechanism to skip/include dotfiles

d. Rollback Capability

   While not providing full transaction semantics, Fsynth attempts
   reasonable rollback of failed operation batches.

e. Immutability And Functional Approach

   Once an operation is created, its parameters are immutable.
   This helps with debugging and ensures operations don't unexpectedly
   change behavior between creation and execution.


3. API Design

The API follows the Command pattern with a queue-based approach.

a. Operation Interface [1]
   
   Each operation encapsulates a specific filesystem action with a standard
   interface including:
   - execute(): performs the operation
   - validate(): pre-checks operation validity
   - checksum(): generates or verifies checksums
   - undo(): reverses the operation (when possible)

b. Queue Management [2]
   
   The system uses an efficient queue implementation with O(1) enqueue/dequeue
   operations.

c. Basic Operations

   Core operations include:
   - CopyFile: Copies a file with checksum verification
   - SymlinkFile: Creates a symlink
   - CreateDirectory: Creates a directory (and parent dirs if needed)
   - DeleteFile: Removes a file with optional backup
   - DeleteDirectory: Removes a directory with safety limits
   - MoveFile: Moves a file with checksum verification
   - ChmodFile: Changes file permissions

d. Processor Interface [3]
   The processor executes the operation queue with proper error handling
   and optional rollback.



4. Implementation Details

a. Operation Representation
   
   Each operation is a Lua table with methods (using metatables) that include:
   - Common fields: source, target, options, checksum_data
   - Operation-specific fields as needed
   - Standard methods matching the operation interface

b. Checksumming
   
   - Uses SHA-256 for robust checksumming
   - Stores checksums for both source and target files
   - Provides options to compare checksums before operations
   - Includes options to bail out if checksums don't match expectations

c. Directory Handling
   
   - Implements iteration with item counting
   - Offers configurable max_items parameter (default ~1000)
   - Stores current count in an accumulator object
   - Provides clear warning/error when limit is reached

d. Error Handling
        
        - Provides detailed error messages with context
        - Implements error classification (fatal vs. non-fatal)
        - Includes option to continue on non-fatal errors
        - Logs all operations and errors
    
    
5. Execution Models
   
   - Standard: Executes operations in order, stopping on first error
   - Validate-first: Validates all operations before executing any
   - Best-effort: Tries all operations, collecting errors
   - Transactional: Attempts rollback of completed operations on failure



6. Integration with Existing Systems

   Fsynth works with Penlight for path handling and filesystem
   operations. Key integration points:

      a. Leverages Penlight's path functions for normalization, joining, etc.
      b. Uses pl.dir for directory operations when appropriate
      c. Wraps pl.file functions for file operations
      d. Utilizes Penlight's utility functions where helpful

   The library is tested with Busted, using mocks to isolate filesystem
   operations for unit testing.


7. Technical & Development

   See the docs/development.txxt for information on package management, logging, testing and best-practices.
